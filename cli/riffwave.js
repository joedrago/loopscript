// Generated by CoffeeScript 1.7.1
(function() {
  var FastBase64, RIFFWAVE, b64toBlob, fs, makeBlobUrl, makeDataURI, writeWAV;

  fs = require("fs");

  FastBase64 = (function() {
    function FastBase64() {
      var i, _i;
      this.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      this.encLookup = [];
      for (i = _i = 0; _i < 4096; i = ++_i) {
        this.encLookup[i] = this.chars[i >> 6] + this.chars[i & 0x3F];
      }
    }

    FastBase64.prototype.encode = function(src) {
      var dst, i, len, n, n1, n2, n3;
      len = src.length;
      dst = '';
      i = 0;
      while (len > 2) {
        n = (src[i] << 16) | (src[i + 1] << 8) | src[i + 2];
        dst += this.encLookup[n >> 12] + this.encLookup[n & 0xFFF];
        len -= 3;
        i += 3;
      }
      if (len > 0) {
        n1 = (src[i] & 0xFC) >> 2;
        n2 = (src[i] & 0x03) << 4;
        if (len > 1) {
          n2 |= (src[++i] & 0xF0) >> 4;
        }
        dst += this.chars[n1];
        dst += this.chars[n2];
        if (len === 2) {
          n3 = (src[i++] & 0x0F) << 2;
          n3 |= (src[i] & 0xC0) >> 6;
          dst += this.chars[n3];
        }
        if (len === 1) {
          dst += '=';
        }
        dst += '=';
      }
      return dst;
    };

    return FastBase64;

  })();

  RIFFWAVE = (function() {
    function RIFFWAVE(sampleRate, data) {
      this.sampleRate = sampleRate;
      this.data = data;
      this.wav = [];
      this.header = {
        chunkId: [0x52, 0x49, 0x46, 0x46],
        chunkSize: 0,
        format: [0x57, 0x41, 0x56, 0x45],
        subChunk1Id: [0x66, 0x6d, 0x74, 0x20],
        subChunk1Size: 16,
        audioFormat: 1,
        numChannels: 1,
        sampleRate: this.sampleRate,
        byteRate: 0,
        blockAlign: 0,
        bitsPerSample: 16,
        subChunk2Id: [0x64, 0x61, 0x74, 0x61],
        subChunk2Size: 0
      };
      this.generate();
    }

    RIFFWAVE.prototype.u32ToArray = function(i) {
      return [i & 0xFF, (i >> 8) & 0xFF, (i >> 16) & 0xFF, (i >> 24) & 0xFF];
    };

    RIFFWAVE.prototype.u16ToArray = function(i) {
      return [i & 0xFF, (i >> 8) & 0xFF];
    };

    RIFFWAVE.prototype.split16bitArray = function(data) {
      var i, j, len, r, _i;
      r = [];
      j = 0;
      len = data.length;
      for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
        r[j++] = data[i] & 0xFF;
        r[j++] = (data[i] >> 8) & 0xFF;
      }
      return r;
    };

    RIFFWAVE.prototype.generate = function() {
      var fb;
      this.header.blockAlign = (this.header.numChannels * this.header.bitsPerSample) >> 3;
      this.header.byteRate = this.header.blockAlign * this.sampleRate;
      this.header.subChunk2Size = this.data.length * (this.header.bitsPerSample >> 3);
      this.header.chunkSize = 36 + this.header.subChunk2Size;
      if (this.header.bitsPerSample === 16) {
        this.data = this.split16bitArray(this.data);
      }
      this.wav = this.header.chunkId.concat(this.u32ToArray(this.header.chunkSize), this.header.format, this.header.subChunk1Id, this.u32ToArray(this.header.subChunk1Size), this.u16ToArray(this.header.audioFormat), this.u16ToArray(this.header.numChannels), this.u32ToArray(this.header.sampleRate), this.u32ToArray(this.header.byteRate), this.u16ToArray(this.header.blockAlign), this.u16ToArray(this.header.bitsPerSample), this.header.subChunk2Id, this.u32ToArray(this.header.subChunk2Size), this.data);
      fb = new FastBase64;
      this.base64Data = fb.encode(this.wav);
      return this.dataURI = 'data:audio/wav;base64,' + this.base64Data;
    };

    RIFFWAVE.prototype.raw = function() {
      return new Buffer(this.base64Data, "base64");
    };

    return RIFFWAVE;

  })();

  writeWAV = function(filename, sampleRate, samples) {
    var wave;
    wave = new RIFFWAVE(sampleRate, samples);
    fs.writeFileSync(filename, wave.raw());
    return true;
  };

  makeDataURI = function(sampleRate, samples) {
    var wave;
    wave = new RIFFWAVE(sampleRate, samples);
    return wave.dataURI;
  };

  b64toBlob = function(b64Data, contentType, sliceSize) {
    var blob, byteArray, byteArrays, byteCharacters, byteNumbers, i, offset, slice, _i, _j, _ref, _ref1;
    contentType = contentType || '';
    sliceSize = sliceSize || 512;
    byteCharacters = atob(b64Data);
    byteArrays = [];
    for (offset = _i = 0, _ref = byteCharacters.length; sliceSize > 0 ? _i < _ref : _i > _ref; offset = _i += sliceSize) {
      slice = byteCharacters.slice(offset, offset + sliceSize);
      byteNumbers = new Array(slice.length);
      for (i = _j = 0, _ref1 = slice.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        byteNumbers[i] = slice.charCodeAt(i);
      }
      byteArray = new Uint8Array(byteNumbers);
      byteArrays.push(byteArray);
    }
    blob = new Blob(byteArrays, {
      type: contentType
    });
    return blob;
  };

  makeBlobUrl = function(sampleRate, samples) {
    var blob, wave;
    wave = new RIFFWAVE(sampleRate, samples);
    blob = b64toBlob(wave.base64Data, "audio/wav");
    return URL.createObjectURL(blob);
  };

  module.exports = {
    RIFFWAVE: RIFFWAVE,
    writeWAV: writeWAV,
    makeDataURI: makeDataURI,
    makeBlobUrl: makeBlobUrl
  };

}).call(this);

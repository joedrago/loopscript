// Generated by CoffeeScript 1.7.1
(function() {
  var Parser, Renderer, clone, countIndent, findFreq, fs, generateBitmapDataURL, jDataView, logDebug, parseBool, renderLoopScript, renderWaveformImage, riffwave, _asLittleEndianHex, _collapseData, _scaleRows,
    __slice = [].slice;

  findFreq = require('./freq').findFreq;

  riffwave = require("./riffwave");

  jDataView = require('../js/jdataview');

  fs = require('fs');

  logDebug = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  };

  clone = function(obj) {
    var flags, key, newInstance;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
      flags = '';
      if (obj.global != null) {
        flags += 'g';
      }
      if (obj.ignoreCase != null) {
        flags += 'i';
      }
      if (obj.multiline != null) {
        flags += 'm';
      }
      if (obj.sticky != null) {
        flags += 'y';
      }
      return new RegExp(obj.source, flags);
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      newInstance[key] = clone(obj[key]);
    }
    return newInstance;
  };

  parseBool = function(v) {
    switch (String(v)) {
      case "true":
        return true;
      case "yes":
        return true;
      case "on":
        return true;
      case "1":
        return true;
      default:
        return false;
    }
  };

  countIndent = function(text) {
    var i, indent, _i, _ref;
    indent = 0;
    for (i = _i = 0, _ref = text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (text[i] === '\t') {
        indent += 8;
      } else {
        indent++;
      }
    }
    return indent;
  };

  _asLittleEndianHex = function(value, bytes) {
    var result;
    result = [];
    while (bytes > 0) {
      result.push(String.fromCharCode(value & 255));
      value >>= 8;
      bytes--;
    }
    return result.join('');
  };

  _collapseData = function(rows, row_padding) {
    var i, j, padding, pixel, pixels_len, result, rows_len, _i, _j;
    rows_len = rows.length;
    pixels_len = rows_len ? rows[0].length : 0;
    padding = '';
    result = [];
    while (row_padding > 0) {
      padding += '\x00';
      row_padding--;
    }
    for (i = _i = 0; 0 <= rows_len ? _i < rows_len : _i > rows_len; i = 0 <= rows_len ? ++_i : --_i) {
      for (j = _j = 0; 0 <= pixels_len ? _j < pixels_len : _j > pixels_len; j = 0 <= pixels_len ? ++_j : --_j) {
        pixel = rows[i][j];
        result.push(String.fromCharCode(pixel[2]) + String.fromCharCode(pixel[1]) + String.fromCharCode(pixel[0]));
      }
      result.push(padding);
    }
    return result.join('');
  };

  _scaleRows = function(rows, scale) {
    var new_row, new_rows, real_h, real_w, scaled_h, scaled_w, x, y, _i, _j;
    real_w = rows.length;
    scaled_w = parseInt(real_w * scale);
    real_h = real_w ? rows[0].length : 0;
    scaled_h = parseInt(real_h * scale);
    new_rows = [];
    for (y = _i = 0; 0 <= scaled_h ? _i < scaled_h : _i > scaled_h; y = 0 <= scaled_h ? ++_i : --_i) {
      new_rows.push(new_row = []);
      for (x = _j = 0; 0 <= scaled_w ? _j < scaled_w : _j > scaled_w; x = 0 <= scaled_w ? ++_j : --_j) {
        new_row.push(rows[parseInt(y / scale)][parseInt(x / scale)]);
      }
    }
    return new_rows;
  };

  generateBitmapDataURL = function(rows, scale) {
    var file, height, num_data_bytes, num_file_bytes, row_padding, width;
    if (!btoa) {
      return false;
    }
    scale = scale || 1;
    if (scale !== 1) {
      rows = _scaleRows(rows, scale);
    }
    height = rows.length;
    width = height ? rows[0].length : 0;
    row_padding = (4 - (width * 3) % 4) % 4;
    num_data_bytes = (width * 3 + row_padding) * height;
    num_file_bytes = 54 + num_data_bytes;
    height = _asLittleEndianHex(height, 4);
    width = _asLittleEndianHex(width, 4);
    num_data_bytes = _asLittleEndianHex(num_data_bytes, 4);
    num_file_bytes = _asLittleEndianHex(num_file_bytes, 4);
    file = 'BM' + num_file_bytes + '\x00\x00' + '\x00\x00' + '\x36\x00\x00\x00' + '\x28\x00\x00\x00' + width + height + '\x01\x00' + '\x18\x00' + '\x00\x00\x00\x00' + num_data_bytes + '\x13\x0B\x00\x00' + '\x13\x0B\x00\x00' + '\x00\x00\x00\x00' + '\x00\x00\x00\x00' + _collapseData(rows, row_padding);
    return 'data:image/bmp;base64,' + btoa(file);
  };

  Parser = (function() {
    function Parser(log) {
      this.log = log;
      this.commentRegex = /^([^#]*?)(\s*#.*)?$/;
      this.onlyWhitespaceRegex = /^\s*$/;
      this.indentRegex = /^(\s*)(\S.*)$/;
      this.leadingUnderscoreRegex = /^_/;
      this.hasCapitalLettersRegex = /[A-Z]/;
      this.isNoteRegex = /[A-La-l]/;
      this.namedStates = {
        "default": {
          srcoctave: 4,
          srcnote: 'a',
          octave: 4,
          note: 'a',
          wave: 'sine',
          bpm: 120,
          duration: 200,
          volume: 1.0,
          clip: true,
          reverb: {
            delay: 0,
            decay: 0
          },
          adsr: {
            a: 0,
            d: 0,
            s: 1,
            r: 1
          }
        }
      };
      this.objectKeys = {
        tone: {
          wave: 'string',
          freq: 'float',
          duration: 'float',
          adsr: 'adsr',
          octave: 'int',
          note: 'string',
          volume: 'float',
          clip: 'bool',
          reverb: 'reverb'
        },
        sample: {
          src: 'string',
          volume: 'float',
          clip: 'bool',
          reverb: 'reverb',
          srcoctave: 'int',
          srcnote: 'string',
          octave: 'int',
          note: 'string'
        },
        loop: {
          bpm: 'int'
        },
        track: {}
      };
      this.stateStack = [];
      this.reset('default', 0);
      this.objects = {};
      this.object = null;
      this.objectScopeReady = false;
    }

    Parser.prototype.isObjectType = function(type) {
      return this.objectKeys[type] != null;
    };

    Parser.prototype.error = function(text) {
      return this.log.error("PARSE ERROR, line " + this.lineNo + ": " + text);
    };

    Parser.prototype.reset = function(name, indent) {
      var newState;
      if (name == null) {
        name = 'default';
      }
      if (indent == null) {
        indent = 0;
      }
      if (!this.namedStates[name]) {
        this.error("invalid reset name: " + name);
        return false;
      }
      newState = clone(this.namedStates[name]);
      newState._indent = indent;
      this.stateStack.push(newState);
      return true;
    };

    Parser.prototype.flatten = function() {
      var flattenedState, key, state, _i, _len, _ref;
      flattenedState = {};
      _ref = this.stateStack;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        state = _ref[_i];
        for (key in state) {
          flattenedState[key] = state[key];
        }
      }
      return flattenedState;
    };

    Parser.prototype.trace = function(prefix) {
      if (prefix == null) {
        prefix = '';
      }
      return this.log.verbose(("trace: " + prefix + " ") + JSON.stringify(this.flatten()));
    };

    Parser.prototype.createObject = function() {
      var data, i, indent, _i, _ref;
      indent = arguments[0], data = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      this.object = {
        _indent: indent
      };
      for (i = _i = 0, _ref = data.length; _i < _ref; i = _i += 2) {
        this.object[data[i]] = data[i + 1];
      }
      this.objectScopeReady = true;
      if (this.object._type === 'loop') {
        this.object._patterns = [];
      }
      if (this.object._type === 'track') {
        this.object._patterns = [];
      }
      if (this.object._name) {
        this.lastObject = this.object._name;
        return logDebug("createObject[" + indent + "]: ", this.lastObject);
      }
    };

    Parser.prototype.finishObject = function() {
      var expectedType, key, state, v;
      if (this.object) {
        state = this.flatten();
        for (key in this.objectKeys[this.object._type]) {
          expectedType = this.objectKeys[this.object._type][key];
          if (state[key] != null) {
            v = state[key];
            this.object[key] = (function() {
              switch (expectedType) {
                case 'int':
                  return parseInt(v);
                case 'float':
                  return parseFloat(v);
                case 'bool':
                  return parseBool(v);
                default:
                  return v;
              }
            })();
          }
        }
        logDebug("finishObject: ", this.object);
        this.objects[this.object._name] = this.object;
      }
      return this.object = null;
    };

    Parser.prototype.creatingObjectType = function(type) {
      if (!this.object) {
        return false;
      }
      if (!this.object._type === type) {
        return false;
      }
      return true;
    };

    Parser.prototype.updateFakeIndents = function(indent) {
      var i, prevIndent, _results;
      if (indent >= 1000) {
        return;
      }
      i = this.stateStack.length - 1;
      _results = [];
      while (i > 0) {
        prevIndent = this.stateStack[i - 1]._indent;
        if ((this.stateStack[i]._indent > 1000) && (prevIndent < indent)) {
          logDebug("updateFakeIndents: changing stack indent " + i + " from " + this.stateStack[i]._indent + " to " + indent);
          this.stateStack[i]._indent = indent;
        }
        _results.push(i--);
      }
      return _results;
    };

    Parser.prototype.pushState = function(indent) {
      if (indent == null) {
        indent = 0;
      }
      logDebug("pushState(" + indent + ")");
      this.updateFakeIndents(indent);
      this.stateStack.push({
        _indent: indent
      });
      return true;
    };

    Parser.prototype.popState = function(indent) {
      var topIndent;
      logDebug("popState(" + indent + ")");
      if (this.object != null) {
        if (indent <= this.object._indent) {
          this.finishObject();
        }
      }
      this.updateFakeIndents(indent);
      while (true) {
        topIndent = this.getTopIndent();
        logDebug("popState(" + indent + ") top indent " + topIndent);
        if (indent === topIndent) {
          break;
        }
        if (this.stateStack.length < 2) {
          return false;
        }
        logDebug("popState(" + indent + ") popping indent " + topIndent);
        this.stateStack.pop();
      }
      return true;
    };

    Parser.prototype.parsePattern = function(pattern) {
      var c, i, length, next, overrideLength, sound, sounds, symbol;
      overrideLength = this.hasCapitalLettersRegex.test(pattern);
      i = 0;
      sounds = [];
      while (i < pattern.length) {
        c = pattern[i];
        if (c !== '.') {
          symbol = c.toLowerCase();
          sound = {
            offset: i
          };
          if (this.isNoteRegex.test(c)) {
            sound.note = symbol;
          }
          if (overrideLength) {
            length = 1;
            while (true) {
              next = pattern[i + 1];
              if (next === symbol) {
                length++;
                i++;
                if (i === pattern.length) {
                  break;
                }
              } else {
                break;
              }
            }
            sound.length = length;
          }
          sounds.push(sound);
        }
        i++;
      }
      return {
        pattern: pattern,
        length: pattern.length,
        sounds: sounds
      };
    };

    Parser.prototype.getTopIndent = function() {
      return this.stateStack[this.stateStack.length - 1]._indent;
    };

    Parser.prototype.processTokens = function(tokens, indent) {
      var cmd, pattern;
      cmd = tokens[0].toLowerCase();
      if (cmd === 'reset') {
        if (!this.reset(tokens[1], indent)) {
          return false;
        }
      } else if (cmd === 'section') {
        this.objectScopeReady = true;
      } else if (this.isObjectType(cmd)) {
        this.createObject(indent, '_type', cmd, '_name', tokens[1]);
      } else if (cmd === 'pattern') {
        if (!(this.creatingObjectType('loop') || this.creatingObjectType('track'))) {
          this.error("unexpected pattern command");
          return false;
        }
        pattern = this.parsePattern(tokens[2]);
        pattern.src = tokens[1];
        this.object._patterns.push(pattern);
      } else if (cmd === 'adsr') {
        this.stateStack[this.stateStack.length - 1][cmd] = {
          a: parseFloat(tokens[1]),
          d: parseFloat(tokens[2]),
          s: parseFloat(tokens[3]),
          r: parseFloat(tokens[4])
        };
      } else if (cmd === 'reverb') {
        this.stateStack[this.stateStack.length - 1][cmd] = {
          delay: parseInt(tokens[1]),
          decay: parseFloat(tokens[2])
        };
      } else {
        if (this.leadingUnderscoreRegex.test(cmd)) {
          this.error("cannot set internal names (underscore prefix)");
          return false;
        }
        this.stateStack[this.stateStack.length - 1][cmd] = tokens[1];
      }
      return true;
    };

    Parser.prototype.parse = function(text) {
      var arrowSection, arrowSections, indent, indentText, line, lineObjs, lines, obj, semiSection, semiSections, topIndent, _, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
      lines = text.split('\n');
      this.lineNo = 0;
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        this.lineNo++;
        line = line.replace(/(\r\n|\n|\r)/gm, "");
        line = this.commentRegex.exec(line)[1];
        if (this.onlyWhitespaceRegex.test(line)) {
          continue;
        }
        _ref = this.indentRegex.exec(line), _ = _ref[0], indentText = _ref[1], line = _ref[2];
        indent = countIndent(indentText);
        lineObjs = [];
        arrowSections = line.split(/\s*->\s*/);
        for (_j = 0, _len1 = arrowSections.length; _j < _len1; _j++) {
          arrowSection = arrowSections[_j];
          semiSections = arrowSection.split(/\s*;\s*/);
          for (_k = 0, _len2 = semiSections.length; _k < _len2; _k++) {
            semiSection = semiSections[_k];
            lineObjs.push({
              indent: indent,
              line: semiSection
            });
          }
          indent += 1000;
        }
        for (_l = 0, _len3 = lineObjs.length; _l < _len3; _l++) {
          obj = lineObjs[_l];
          logDebug("handling indent: " + JSON.stringify(obj));
          topIndent = this.getTopIndent();
          if (obj.indent > topIndent) {
            this.pushState(obj.indent);
          } else {
            if (!this.popState(obj.indent)) {
              this.log.error("unexpected outdent");
              return false;
            }
          }
          logDebug("processing: " + JSON.stringify(obj));
          if (!this.processTokens(obj.line.split(/\s+/), obj.indent)) {
            return false;
          }
        }
      }
      this.popState(0);
      return true;
    };

    return Parser;

  })();

  Renderer = (function() {
    function Renderer(log, sampleRate, readLocalFiles, objects) {
      this.log = log;
      this.sampleRate = sampleRate;
      this.readLocalFiles = readLocalFiles;
      this.objects = objects;
      this.soundCache = {};
    }

    Renderer.prototype.error = function(text) {
      return this.log.error("RENDER ERROR: " + text);
    };

    Renderer.prototype.generateEnvelope = function(adsr, length) {
      var AtoD, DtoS, StoR, attackLen, decayLen, envelope, i, peakSustainDelta, releaseLen, sustain, sustainLen, _i, _j, _k, _l;
      envelope = Array(length);
      AtoD = Math.floor(adsr.a * length);
      DtoS = Math.floor(adsr.d * length);
      StoR = Math.floor(adsr.r * length);
      attackLen = AtoD;
      decayLen = DtoS - AtoD;
      sustainLen = StoR - DtoS;
      releaseLen = length - StoR;
      sustain = adsr.s;
      peakSustainDelta = 1.0 - sustain;
      for (i = _i = 0; 0 <= attackLen ? _i < attackLen : _i > attackLen; i = 0 <= attackLen ? ++_i : --_i) {
        envelope[i] = i / attackLen;
      }
      for (i = _j = 0; 0 <= decayLen ? _j < decayLen : _j > decayLen; i = 0 <= decayLen ? ++_j : --_j) {
        envelope[AtoD + i] = 1.0 - (peakSustainDelta * (i / decayLen));
      }
      for (i = _k = 0; 0 <= sustainLen ? _k < sustainLen : _k > sustainLen; i = 0 <= sustainLen ? ++_k : --_k) {
        envelope[DtoS + i] = sustain;
      }
      for (i = _l = 0; 0 <= releaseLen ? _l < releaseLen : _l > releaseLen; i = 0 <= releaseLen ? ++_l : --_l) {
        envelope[StoR + i] = sustain - (sustain * (i / releaseLen));
      }
      return envelope;
    };

    Renderer.prototype.renderTone = function(toneObj, overrides) {
      var A, B, amplitude, envelope, freq, i, length, period, sample, samples, _i;
      amplitude = 10000;
      if (overrides.length > 0) {
        length = overrides.length;
      } else {
        length = Math.floor(toneObj.duration * this.sampleRate / 1000);
      }
      samples = Array(length);
      A = 200;
      B = 0.5;
      if (overrides.note != null) {
        freq = findFreq(toneObj.octave, overrides.note);
      } else if (toneObj.freq != null) {
        freq = toneObj.freq;
      } else {
        freq = findFreq(toneObj.octave, toneObj.note);
      }
      envelope = this.generateEnvelope(toneObj.adsr, length);
      period = this.sampleRate / freq;
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        if (toneObj.wave === "sawtooth") {
          sample = ((i % period) / period) - 0.5;
        } else {
          sample = Math.sin(i / period * 2 * Math.PI);
          if (toneObj.wave === "square") {
            sample = sample > 0 ? 1 : -1;
          }
        }
        samples[i] = sample * amplitude * envelope[i];
      }
      return {
        samples: samples,
        length: samples.length
      };
    };

    Renderer.prototype.renderSample = function(sampleObj, overrides) {
      var data, factor, i, newfreq, oldfreq, overrideNote, relength, resamples, samples, subchunk2Size, view, _i, _j;
      view = null;
      if (this.readLocalFiles) {
        data = fs.readFileSync(sampleObj.src);
        view = new jDataView(data, 0, data.length, true);
      } else {
        $.ajax({
          url: sampleObj.src,
          mimeType: 'text/plain; charset=x-user-defined',
          success: function(data) {
            return view = new jDataView(data, 0, data.length, true);
          },
          async: false
        });
      }
      if (!view) {
        return {
          samples: [],
          length: 0
        };
      }
      view.seek(40);
      subchunk2Size = view.getInt32();
      samples = [];
      while (view.tell() + 1 < view.byteLength) {
        samples.push(view.getInt16());
      }
      overrideNote = overrides.note ? overrides.note : sampleObj.note;
      if ((overrideNote !== sampleObj.srcnote) || (sampleObj.octave !== sampleObj.srcoctave)) {
        oldfreq = findFreq(sampleObj.srcoctave, sampleObj.srcnote);
        newfreq = findFreq(sampleObj.octave, overrideNote);
        factor = oldfreq / newfreq;
        relength = Math.floor(samples.length * factor);
        resamples = Array(relength);
        for (i = _i = 0; 0 <= relength ? _i < relength : _i > relength; i = 0 <= relength ? ++_i : --_i) {
          resamples[i] = 0;
        }
        for (i = _j = 0; 0 <= relength ? _j < relength : _j > relength; i = 0 <= relength ? ++_j : --_j) {
          resamples[i] = samples[Math.floor(i / factor)];
        }
        return {
          samples: resamples,
          length: resamples.length
        };
      } else {
        return {
          samples: samples,
          length: samples.length
        };
      }
    };

    Renderer.prototype.renderLoop = function(loopObj) {
      var beatCount, copyLen, end, fadeClip, i, j, obj, offset, offsetLength, overflowLength, overrides, pattern, patternSamples, samples, samplesPerBeat, sectionCount, sound, srcSound, totalLength, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _s, _t;
      beatCount = 0;
      _ref = loopObj._patterns;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pattern = _ref[_i];
        if (beatCount < pattern.length) {
          beatCount = pattern.length;
        }
      }
      samplesPerBeat = this.sampleRate / (loopObj.bpm / 60) / 4;
      totalLength = samplesPerBeat * beatCount;
      overflowLength = totalLength;
      _ref1 = loopObj._patterns;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        pattern = _ref1[_j];
        sectionCount = pattern.length / 16;
        offsetLength = Math.floor(totalLength / 16 / sectionCount);
        _ref2 = pattern.sounds;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          sound = _ref2[_k];
          overrides = {};
          if (sound.length > 0) {
            overrides.length = sound.length * offsetLength;
          }
          if (sound.note != null) {
            overrides.note = sound.note;
          }
          sound._render = this.render(pattern.src, overrides);
          end = (sound.offset * offsetLength) + sound._render.samples.length;
          if (overflowLength < end) {
            overflowLength = end;
          }
        }
      }
      samples = Array(overflowLength);
      for (i = _l = 0; 0 <= overflowLength ? _l < overflowLength : _l > overflowLength; i = 0 <= overflowLength ? ++_l : --_l) {
        samples[i] = 0;
      }
      _ref3 = loopObj._patterns;
      for (_m = 0, _len3 = _ref3.length; _m < _len3; _m++) {
        pattern = _ref3[_m];
        sectionCount = pattern.length / 16;
        offsetLength = Math.floor(totalLength / 16 / sectionCount);
        patternSamples = Array(overflowLength);
        for (i = _n = 0; 0 <= overflowLength ? _n < overflowLength : _n > overflowLength; i = 0 <= overflowLength ? ++_n : --_n) {
          patternSamples[i] = 0;
        }
        _ref4 = pattern.sounds;
        for (_o = 0, _len4 = _ref4.length; _o < _len4; _o++) {
          sound = _ref4[_o];
          srcSound = sound._render;
          obj = this.getObject(pattern.src);
          offset = sound.offset * offsetLength;
          copyLen = srcSound.samples.length;
          if ((offset + copyLen) > overflowLength) {
            copyLen = overflowLength - offset;
          }
          if (obj.clip) {
            fadeClip = 200;
            if (offset > fadeClip) {
              for (j = _p = 0; 0 <= fadeClip ? _p < fadeClip : _p > fadeClip; j = 0 <= fadeClip ? ++_p : --_p) {
                v = patternSamples[offset - fadeClip + j];
                patternSamples[offset - fadeClip + j] = Math.floor(v * ((fadeClip - j) / fadeClip));
              }
            }
            for (j = _q = offset; offset <= overflowLength ? _q < overflowLength : _q > overflowLength; j = offset <= overflowLength ? ++_q : --_q) {
              patternSamples[j] = 0;
            }
            for (j = _r = 0; 0 <= copyLen ? _r < copyLen : _r > copyLen; j = 0 <= copyLen ? ++_r : --_r) {
              patternSamples[offset + j] = srcSound.samples[j];
            }
          } else {
            for (j = _s = 0; 0 <= copyLen ? _s < copyLen : _s > copyLen; j = 0 <= copyLen ? ++_s : --_s) {
              patternSamples[offset + j] += srcSound.samples[j];
            }
          }
        }
        for (j = _t = 0; 0 <= overflowLength ? _t < overflowLength : _t > overflowLength; j = 0 <= overflowLength ? ++_t : --_t) {
          samples[j] += patternSamples[j];
        }
      }
      return {
        samples: samples,
        length: totalLength
      };
    };

    Renderer.prototype.renderTrack = function(trackObj) {
      var copyLen, i, j, overflowLength, pattern, pieceCount, pieceIndex, pieceOverflowLength, pieceTotalLength, possibleMaxLength, samples, srcSound, totalLength, trackOffset, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _o, _ref, _ref1, _ref2;
      pieceCount = 0;
      _ref = trackObj._patterns;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pattern = _ref[_i];
        if (pieceCount < pattern.pattern.length) {
          pieceCount = pattern.pattern.length;
        }
      }
      totalLength = 0;
      overflowLength = 0;
      pieceTotalLength = Array(pieceCount);
      pieceOverflowLength = Array(pieceCount);
      for (pieceIndex = _j = 0; 0 <= pieceCount ? _j < pieceCount : _j > pieceCount; pieceIndex = 0 <= pieceCount ? ++_j : --_j) {
        pieceTotalLength[pieceIndex] = 0;
        pieceOverflowLength[pieceIndex] = 0;
        _ref1 = trackObj._patterns;
        for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
          pattern = _ref1[_k];
          if ((pieceIndex < pattern.pattern.length) && (pattern.pattern[pieceIndex] !== '.')) {
            srcSound = this.render(pattern.src);
            if (pieceTotalLength[pieceIndex] < srcSound.length) {
              pieceTotalLength[pieceIndex] = srcSound.length;
            }
            if (pieceOverflowLength[pieceIndex] < srcSound.samples.length) {
              pieceOverflowLength[pieceIndex] = srcSound.samples.length;
            }
          }
        }
        possibleMaxLength = totalLength + pieceOverflowLength[pieceIndex];
        if (overflowLength < possibleMaxLength) {
          overflowLength = possibleMaxLength;
        }
        totalLength += pieceTotalLength[pieceIndex];
      }
      samples = Array(overflowLength);
      for (i = _l = 0; 0 <= overflowLength ? _l < overflowLength : _l > overflowLength; i = 0 <= overflowLength ? ++_l : --_l) {
        samples[i] = 0;
      }
      _ref2 = trackObj._patterns;
      for (_m = 0, _len2 = _ref2.length; _m < _len2; _m++) {
        pattern = _ref2[_m];
        trackOffset = 0;
        srcSound = this.render(pattern.src, {});
        for (pieceIndex = _n = 0; 0 <= pieceCount ? _n < pieceCount : _n > pieceCount; pieceIndex = 0 <= pieceCount ? ++_n : --_n) {
          if ((pieceIndex < pattern.pattern.length) && (pattern.pattern[pieceIndex] !== '.')) {
            copyLen = srcSound.samples.length;
            if ((trackOffset + copyLen) > overflowLength) {
              copyLen = overflowLength - trackOffset;
            }
            for (j = _o = 0; 0 <= copyLen ? _o < copyLen : _o > copyLen; j = 0 <= copyLen ? ++_o : --_o) {
              samples[trackOffset + j] += srcSound.samples[j];
            }
          }
          trackOffset += pieceTotalLength[pieceIndex];
        }
      }
      return {
        samples: samples,
        length: totalLength
      };
    };

    Renderer.prototype.calcCacheName = function(type, which, overrides) {
      var name;
      if ((type !== 'tone') && (type !== 'sample')) {
        return which;
      }
      name = which;
      if (overrides.note) {
        name += "/N" + overrides.note;
      }
      if (overrides.length) {
        name += "/L" + overrides.length;
      }
      return name;
    };

    Renderer.prototype.getObject = function(which) {
      var object;
      object = this.objects[which];
      if (!object) {
        this.error("no such object " + which);
        return null;
      }
      return object;
    };

    Renderer.prototype.render = function(which, overrides) {
      var cacheName, delaySamples, i, object, samples, sound, totalLength, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
      object = this.getObject(which);
      if (!object) {
        return null;
      }
      cacheName = this.calcCacheName(object._type, which, overrides);
      if (this.soundCache[cacheName]) {
        return this.soundCache[cacheName];
      }
      sound = (function() {
        switch (object._type) {
          case 'tone':
            return this.renderTone(object, overrides);
          case 'sample':
            return this.renderSample(object, overrides);
          case 'loop':
            return this.renderLoop(object);
          case 'track':
            return this.renderTrack(object);
          default:
            this.error("unknown type " + object._type);
            return null;
        }
      }).call(this);
      if ((object.volume != null) && (object.volume !== 1.0)) {
        for (i = _i = 0, _ref = sound.samples.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          sound.samples[i] *= object.volume;
        }
      }
      if ((object.reverb != null) && (object.reverb.delay > 0)) {
        delaySamples = Math.floor(object.reverb.delay * this.sampleRate / 1000);
        if (sound.samples.length > delaySamples) {
          totalLength = sound.samples.length + (delaySamples * 8);
          samples = Array(totalLength);
          for (i = _j = 0, _ref1 = sound.samples.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            samples[i] = sound.samples[i];
          }
          for (i = _k = _ref2 = sound.samples.length; _ref2 <= totalLength ? _k < totalLength : _k > totalLength; i = _ref2 <= totalLength ? ++_k : --_k) {
            samples[i] = 0;
          }
          for (i = _l = 0, _ref3 = totalLength - delaySamples; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
            samples[i + delaySamples] += Math.floor(samples[i] * object.reverb.decay);
          }
          sound.samples = samples;
        }
      }
      this.log.verbose("Rendered " + cacheName + ".");
      this.soundCache[cacheName] = sound;
      return sound;
    };

    return Renderer;

  })();

  renderWaveformImage = function(samples, width, height, backgroundColor, waveformColor) {
    var a, i, j, lineHeight, lineOffset, peak, row, rows, sample, sampleAvg, sampleIndex, sampleMax, sampleOffset, sampleSum, samplesPerCol, _i, _j, _k, _l, _len, _m, _n, _o, _ref;
    if (backgroundColor == null) {
      backgroundColor = [255, 255, 255];
    }
    if (waveformColor == null) {
      waveformColor = [255, 0, 0];
    }
    rows = [];
    for (j = _i = 0; 0 <= height ? _i < height : _i > height; j = 0 <= height ? ++_i : --_i) {
      row = [];
      for (i = _j = 0; 0 <= width ? _j < width : _j > width; i = 0 <= width ? ++_j : --_j) {
        row.push(backgroundColor);
      }
      rows.push(row);
    }
    samplesPerCol = Math.floor(samples.length / width);
    peak = 0;
    for (_k = 0, _len = samples.length; _k < _len; _k++) {
      sample = samples[_k];
      a = Math.abs(sample);
      if (peak < a) {
        peak = a;
      }
    }
    peak = Math.floor(peak * 1.1);
    if (peak === 0) {
      row = rows[Math.floor(height / 2)];
      for (i = _l = 0; 0 <= width ? _l < width : _l > width; i = 0 <= width ? ++_l : --_l) {
        row[i] = waveformColor;
      }
    } else {
      for (i = _m = 0; 0 <= width ? _m < width : _m > width; i = 0 <= width ? ++_m : --_m) {
        sampleOffset = Math.floor((i / width) * samples.length);
        sampleSum = 0;
        sampleMax = 0;
        for (sampleIndex = _n = sampleOffset, _ref = sampleOffset + samplesPerCol; sampleOffset <= _ref ? _n < _ref : _n > _ref; sampleIndex = sampleOffset <= _ref ? ++_n : --_n) {
          a = Math.abs(samples[sampleIndex]);
          sampleSum += a;
          if (sampleMax < a) {
            sampleMax = a;
          }
        }
        sampleAvg = Math.floor(sampleSum / samplesPerCol);
        lineHeight = Math.floor(sampleMax / peak * height);
        lineOffset = (height - lineHeight) >> 1;
        if (lineHeight === 0) {
          lineHeight = 1;
        }
        for (j = _o = 0; 0 <= lineHeight ? _o < lineHeight : _o > lineHeight; j = 0 <= lineHeight ? ++_o : --_o) {
          row = rows[j + lineOffset];
          row[i] = waveformColor;
        }
      }
    }
    return generateBitmapDataURL(rows);
  };

  renderLoopScript = function(args) {
    var logObj, outputSound, parser, renderer, ret, sampleRate, which;
    logObj = args.log;
    logObj.verbose("Parsing...");
    parser = new Parser(logObj);
    parser.parse(args.script);
    which = args.which;
    if (which == null) {
      which = parser.lastObject;
    }
    if (which) {
      sampleRate = 44100;
      logObj.verbose("Rendering...");
      renderer = new Renderer(logObj, sampleRate, args.readLocalFiles, parser.objects);
      outputSound = renderer.render(which, {});
      ret = {};
      if (args.wavFilename) {
        riffwave.writeWAV(args.outputFilename, sampleRate, outputSound.samples);
      } else {
        ret.wavUrl = riffwave.makeBlobUrl(sampleRate, outputSound.samples);
      }
      if ((args.imageWidth != null) && (args.imageHeight != null) && (args.imageWidth > 0) && (args.imageHeight > 0)) {
        ret.imageUrl = renderWaveformImage(outputSound.samples, args.imageWidth, args.imageHeight, args.imageBackgroundColor, args.imageWaveformColor);
      }
      return ret;
    }
    return null;
  };

  module.exports = {
    render: renderLoopScript
  };

}).call(this);

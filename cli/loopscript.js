// Generated by CoffeeScript 1.6.3
(function() {
  var IndentStack, Parser, Renderer, clone, countIndent, findFreq, fs, jDataView, parseBool, renderLoopScript, riffwave,
    __slice = [].slice;

  findFreq = require('./freq').findFreq;

  riffwave = require("./riffwave");

  jDataView = require('../js/jdataview');

  fs = require('fs');

  clone = function(obj) {
    var flags, key, newInstance;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
      flags = '';
      if (obj.global != null) {
        flags += 'g';
      }
      if (obj.ignoreCase != null) {
        flags += 'i';
      }
      if (obj.multiline != null) {
        flags += 'm';
      }
      if (obj.sticky != null) {
        flags += 'y';
      }
      return new RegExp(obj.source, flags);
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      newInstance[key] = clone(obj[key]);
    }
    return newInstance;
  };

  parseBool = function(v) {
    switch (String(v)) {
      case "true":
        return true;
      case "yes":
        return true;
      case "on":
        return true;
      case "1":
        return true;
      default:
        return false;
    }
  };

  IndentStack = (function() {
    function IndentStack() {
      this.stack = [0];
    }

    IndentStack.prototype.push = function(indent) {
      return this.stack.push(indent);
    };

    IndentStack.prototype.pop = function() {
      if (this.stack.length > 1) {
        this.stack.pop();
        return true;
      }
      return false;
    };

    IndentStack.prototype.top = function() {
      return this.stack[this.stack.length - 1];
    };

    return IndentStack;

  })();

  countIndent = function(text) {
    var i, indent, _i, _ref;
    indent = 0;
    for (i = _i = 0, _ref = text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (text[i] === '\t') {
        indent += 8;
      } else {
        indent++;
      }
    }
    return indent;
  };

  Parser = (function() {
    function Parser(log) {
      this.log = log;
      this.commentRegex = /^([^#]*?)(\s*#.*)?$/;
      this.onlyWhitespaceRegex = /^\s*$/;
      this.indentRegex = /^(\s*)(\S.*)$/;
      this.leadingUnderscoreRegex = /^_/;
      this.hasCapitalLettersRegex = /[A-Z]/;
      this.isNoteRegex = /[A-La-l]/;
      this.namedStates = {
        "default": {
          wave: 'sine',
          bpm: 120,
          duration: 200,
          beats: 4,
          octave: 4,
          note: 'a',
          volume: 1.0,
          clip: true,
          adsr: {
            a: 0,
            d: 0,
            s: 1,
            r: 1
          }
        }
      };
      this.objectKeys = {
        tone: {
          wave: 'string',
          freq: 'float',
          duration: 'float',
          adsr: 'adsr',
          octave: 'int',
          note: 'string',
          volume: 'float',
          clip: 'bool'
        },
        sample: {
          src: 'string',
          volume: 'float',
          clip: 'bool'
        },
        loop: {
          bpm: 'int',
          beats: 'int'
        },
        track: {}
      };
      this.indentStack = new IndentStack;
      this.stateStack = [];
      this.reset('default');
      this.objects = {};
      this.object = null;
      this.objectScopeReady = false;
    }

    Parser.prototype.isObjectType = function(type) {
      return this.objectKeys[type] != null;
    };

    Parser.prototype.error = function(text) {
      return this.log.error("PARSE ERROR, line " + this.lineNo + ": " + text);
    };

    Parser.prototype.reset = function(name) {
      if (name == null) {
        name = 'default';
      }
      if (!this.namedStates[name]) {
        this.error("invalid reset name: " + name);
        return false;
      }
      this.stateStack.push(clone(this.namedStates[name]));
      return true;
    };

    Parser.prototype.flatten = function() {
      var flattenedState, key, state, _i, _len, _ref;
      flattenedState = {};
      _ref = this.stateStack;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        state = _ref[_i];
        for (key in state) {
          flattenedState[key] = state[key];
        }
      }
      return flattenedState;
    };

    Parser.prototype.trace = function(prefix) {
      if (prefix == null) {
        prefix = '';
      }
      return this.log.verbose(("trace: " + prefix + " ") + JSON.stringify(this.flatten()));
    };

    Parser.prototype.createObject = function() {
      var data, i, _i, _ref;
      data = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.finishObject();
      this.object = {};
      for (i = _i = 0, _ref = data.length; _i < _ref; i = _i += 2) {
        this.object[data[i]] = data[i + 1];
      }
      this.objectScopeReady = true;
      if (this.object._type === 'loop') {
        this.object._patterns = [];
      }
      if (this.object._type === 'track') {
        this.object._patterns = [];
      }
      if (this.object._name) {
        return this.lastObject = this.object._name;
      }
    };

    Parser.prototype.finishObject = function() {
      var expectedType, key, state, v;
      if (this.object) {
        state = this.flatten();
        for (key in this.objectKeys[this.object._type]) {
          expectedType = this.objectKeys[this.object._type][key];
          if (state[key] != null) {
            v = state[key];
            this.object[key] = (function() {
              switch (expectedType) {
                case 'int':
                  return parseInt(v);
                case 'float':
                  return parseFloat(v);
                case 'bool':
                  return parseBool(v);
                default:
                  return v;
              }
            })();
          }
        }
        this.objects[this.object._name] = this.object;
      }
      return this.object = null;
    };

    Parser.prototype.creatingObjectType = function(type) {
      if (!this.object) {
        return false;
      }
      if (!this.object._type === type) {
        return false;
      }
      return true;
    };

    Parser.prototype.pushScope = function() {
      if (!this.objectScopeReady) {
        this.error("unexpected indent");
        return false;
      }
      this.objectScopeReady = false;
      this.stateStack.push({
        _scope: true
      });
      return true;
    };

    Parser.prototype.popScope = function() {
      var top;
      this.finishObject();
      while (true) {
        if (this.stateStack.length === 0) {
          this.error("state stack is empty! something bad has happened");
        }
        top = this.stateStack[this.stateStack.length - 1];
        if (top._scope != null) {
          break;
        }
        this.stateStack.pop();
      }
      this.stateStack.pop();
      return true;
    };

    Parser.prototype.parsePattern = function(pattern) {
      var c, i, length, next, overrideLength, sound, sounds, symbol;
      overrideLength = this.hasCapitalLettersRegex.test(pattern);
      i = 0;
      sounds = [];
      while (i < pattern.length) {
        c = pattern[i];
        if (c !== '.') {
          symbol = c.toLowerCase();
          sound = {
            offset: i
          };
          if (this.isNoteRegex.test(c)) {
            sound.note = symbol;
          }
          if (overrideLength) {
            length = 1;
            while (true) {
              next = pattern[i + 1];
              if (next === symbol) {
                length++;
                i++;
                if (i === pattern.length) {
                  break;
                }
              } else {
                break;
              }
            }
            sound.length = length;
          }
          sounds.push(sound);
        }
        i++;
      }
      return {
        pattern: pattern,
        length: pattern.length,
        sounds: sounds
      };
    };

    Parser.prototype.processTokens = function(tokens) {
      var cmd, pattern;
      cmd = tokens[0].toLowerCase();
      if (cmd === 'reset') {
        if (!this.reset(tokens[1])) {
          return false;
        }
      } else if (cmd === 'section') {
        this.objectScopeReady = true;
      } else if (this.isObjectType(cmd)) {
        this.createObject('_type', cmd, '_name', tokens[1]);
      } else if (cmd === 'pattern') {
        if (!(this.creatingObjectType('loop') || this.creatingObjectType('track'))) {
          this.error("unexpected pattern command");
          return false;
        }
        pattern = this.parsePattern(tokens[2]);
        pattern.src = tokens[1];
        this.object._patterns.push(pattern);
      } else if (cmd === 'adsr') {
        this.stateStack[this.stateStack.length - 1][cmd] = {
          a: parseFloat(tokens[1]),
          d: parseFloat(tokens[2]),
          s: parseFloat(tokens[3]),
          r: parseFloat(tokens[4])
        };
      } else {
        if (this.leadingUnderscoreRegex.test(cmd)) {
          this.error("cannot set internal names (underscore prefix)");
          return false;
        }
        this.stateStack[this.stateStack.length - 1][cmd] = tokens[1];
      }
      return true;
    };

    Parser.prototype.parse = function(text) {
      var indent, indentText, line, lines, topIndent, _, _i, _len, _ref;
      lines = text.split('\n');
      this.lineNo = 0;
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        this.lineNo++;
        line = line.replace(/(\r\n|\n|\r)/gm, "");
        line = this.commentRegex.exec(line)[1];
        if (this.onlyWhitespaceRegex.test(line)) {
          continue;
        }
        _ref = this.indentRegex.exec(line), _ = _ref[0], indentText = _ref[1], line = _ref[2];
        indent = countIndent(indentText);
        topIndent = this.indentStack.top();
        if (indent === topIndent) {

        } else if (indent > topIndent) {
          this.indentStack.push(indent);
          if (!this.pushScope()) {
            return false;
          }
        } else {
          while (true) {
            if (!this.indentStack.pop()) {
              this.log.error("Unexpected indent " + indent + " on line " + lineNo + ": " + line);
              return false;
            }
            if (!this.popScope()) {
              return false;
            }
            if (this.indentStack.top() === indent) {
              break;
            }
          }
        }
        if (!this.processTokens(line.split(/\s+/))) {
          return false;
        }
      }
      while (this.indentStack.pop()) {
        this.popScope();
      }
      this.finishObject();
      return true;
    };

    return Parser;

  })();

  Renderer = (function() {
    function Renderer(log, sampleRate, readLocalFiles, objects) {
      this.log = log;
      this.sampleRate = sampleRate;
      this.readLocalFiles = readLocalFiles;
      this.objects = objects;
      this.soundCache = {};
    }

    Renderer.prototype.error = function(text) {
      return this.log.error("RENDER ERROR: " + text);
    };

    Renderer.prototype.generateEnvelope = function(adsr, length) {
      var AtoD, DtoS, StoR, attackLen, decayLen, envelope, i, peakSustainDelta, releaseLen, sustain, sustainLen, _i, _j, _k, _l;
      envelope = Array(length);
      AtoD = Math.floor(adsr.a * length);
      DtoS = Math.floor(adsr.d * length);
      StoR = Math.floor(adsr.r * length);
      attackLen = AtoD;
      decayLen = DtoS - AtoD;
      sustainLen = StoR - DtoS;
      releaseLen = length - StoR;
      sustain = adsr.s;
      peakSustainDelta = 1.0 - sustain;
      for (i = _i = 0; 0 <= attackLen ? _i < attackLen : _i > attackLen; i = 0 <= attackLen ? ++_i : --_i) {
        envelope[i] = i / attackLen;
      }
      for (i = _j = 0; 0 <= decayLen ? _j < decayLen : _j > decayLen; i = 0 <= decayLen ? ++_j : --_j) {
        envelope[AtoD + i] = 1.0 - (peakSustainDelta * (i / decayLen));
      }
      for (i = _k = 0; 0 <= sustainLen ? _k < sustainLen : _k > sustainLen; i = 0 <= sustainLen ? ++_k : --_k) {
        envelope[DtoS + i] = sustain;
      }
      for (i = _l = 0; 0 <= releaseLen ? _l < releaseLen : _l > releaseLen; i = 0 <= releaseLen ? ++_l : --_l) {
        envelope[StoR + i] = sustain - (sustain * (i / releaseLen));
      }
      return envelope;
    };

    Renderer.prototype.renderTone = function(toneObj, overrides) {
      var A, B, amplitude, envelope, freq, i, length, offset, period, samples, sine, _i;
      offset = 0;
      amplitude = 10000;
      if (overrides.length > 0) {
        length = overrides.length;
      } else {
        length = Math.floor(toneObj.duration * this.sampleRate / 1000);
      }
      samples = Array(length);
      A = 200;
      B = 0.5;
      if (overrides.note != null) {
        freq = findFreq(toneObj.octave, overrides.note);
      } else if (toneObj.freq != null) {
        freq = toneObj.freq;
      } else {
        freq = findFreq(toneObj.octave, toneObj.note);
      }
      envelope = this.generateEnvelope(toneObj.adsr, length);
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        period = this.sampleRate / freq;
        sine = Math.sin(offset + i / period * 2 * Math.PI);
        samples[i] = sine * amplitude * envelope[i] * toneObj.volume;
      }
      return {
        samples: samples,
        length: samples.length
      };
    };

    Renderer.prototype.renderSample = function(sampleObj) {
      var data, i, samples, subchunk2Size, view, _i, _ref;
      view = null;
      if (this.readLocalFiles) {
        data = fs.readFileSync(sampleObj.src);
        view = new jDataView(data, 0, data.length, true);
      } else {
        $.ajax({
          url: sampleObj.src,
          mimeType: 'text/plain; charset=x-user-defined',
          success: function(data) {
            return view = new jDataView(data, 0, data.length, true);
          },
          async: false
        });
      }
      if (!view) {
        return {
          samples: [],
          length: 0
        };
      }
      view.seek(40);
      subchunk2Size = view.getInt32();
      samples = [];
      while (view.tell() + 1 < view.byteLength) {
        samples.push(view.getInt16());
      }
      for (i = _i = 0, _ref = samples.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        samples[i] *= sampleObj.volume;
      }
      return {
        samples: samples,
        length: samples.length
      };
    };

    Renderer.prototype.renderLoop = function(loopObj) {
      var beatCount, copyLen, fadeClip, i, j, obj, offset, offsetLength, overrides, pattern, patternSamples, samples, samplesPerBeat, sectionCount, sound, srcSound, totalLength, v, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _o, _p, _q, _ref, _ref1, _ref2;
      beatCount = 0;
      _ref = loopObj._patterns;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pattern = _ref[_i];
        if (beatCount < pattern.length) {
          beatCount = pattern.length;
        }
      }
      samplesPerBeat = this.sampleRate / (loopObj.bpm / 60) / loopObj.beats;
      totalLength = samplesPerBeat * beatCount;
      samples = Array(totalLength);
      for (i = _j = 0; 0 <= totalLength ? _j < totalLength : _j > totalLength; i = 0 <= totalLength ? ++_j : --_j) {
        samples[i] = 0;
      }
      _ref1 = loopObj._patterns;
      for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
        pattern = _ref1[_k];
        patternSamples = Array(totalLength);
        for (i = _l = 0; 0 <= totalLength ? _l < totalLength : _l > totalLength; i = 0 <= totalLength ? ++_l : --_l) {
          patternSamples[i] = 0;
        }
        _ref2 = pattern.sounds;
        for (_m = 0, _len2 = _ref2.length; _m < _len2; _m++) {
          sound = _ref2[_m];
          overrides = {};
          sectionCount = pattern.length / 16;
          offsetLength = Math.floor(totalLength / 16 / sectionCount);
          if (sound.length > 0) {
            overrides.length = sound.length * offsetLength;
          }
          if (sound.note != null) {
            overrides.note = sound.note;
          }
          srcSound = this.render(pattern.src, overrides);
          obj = this.getObject(pattern.src);
          offset = sound.offset * offsetLength;
          copyLen = srcSound.length;
          if ((offset + copyLen) > totalLength) {
            copyLen = totalLength - offset;
          }
          if (obj.clip) {
            fadeClip = 200;
            if (offset > fadeClip) {
              for (j = _n = 0; 0 <= fadeClip ? _n < fadeClip : _n > fadeClip; j = 0 <= fadeClip ? ++_n : --_n) {
                v = patternSamples[offset - fadeClip + j];
                patternSamples[offset - fadeClip + j] = Math.floor(v * ((fadeClip - j) / fadeClip));
              }
            }
            for (j = _o = 0; 0 <= copyLen ? _o < copyLen : _o > copyLen; j = 0 <= copyLen ? ++_o : --_o) {
              patternSamples[offset + j] = srcSound.samples[j];
            }
          } else {
            for (j = _p = 0; 0 <= copyLen ? _p < copyLen : _p > copyLen; j = 0 <= copyLen ? ++_p : --_p) {
              patternSamples[offset + j] += srcSound.samples[j];
            }
          }
        }
        for (j = _q = 0; 0 <= totalLength ? _q < totalLength : _q > totalLength; j = 0 <= totalLength ? ++_q : --_q) {
          samples[j] += patternSamples[j];
        }
      }
      return {
        samples: samples,
        length: samples.length
      };
    };

    Renderer.prototype.renderTrack = function(trackObj) {
      var copyLen, i, j, pattern, pieceCount, pieceIndex, pieceLengths, samples, srcSound, totalLength, trackOffset, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _o, _ref, _ref1, _ref2;
      pieceCount = 0;
      _ref = trackObj._patterns;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pattern = _ref[_i];
        if (pieceCount < pattern.pattern.length) {
          pieceCount = pattern.pattern.length;
        }
      }
      totalLength = 0;
      pieceLengths = Array(pieceCount);
      for (pieceIndex = _j = 0; 0 <= pieceCount ? _j < pieceCount : _j > pieceCount; pieceIndex = 0 <= pieceCount ? ++_j : --_j) {
        pieceLengths[pieceIndex] = 0;
        _ref1 = trackObj._patterns;
        for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
          pattern = _ref1[_k];
          if ((pieceIndex < pattern.pattern.length) && (pattern.pattern[pieceIndex] !== '.')) {
            srcSound = this.render(pattern.src);
            if (pieceLengths[pieceIndex] < srcSound.length) {
              pieceLengths[pieceIndex] = srcSound.length;
            }
          }
        }
        totalLength += pieceLengths[pieceIndex];
      }
      samples = Array(totalLength);
      for (i = _l = 0; 0 <= totalLength ? _l < totalLength : _l > totalLength; i = 0 <= totalLength ? ++_l : --_l) {
        samples[i] = 0;
      }
      _ref2 = trackObj._patterns;
      for (_m = 0, _len2 = _ref2.length; _m < _len2; _m++) {
        pattern = _ref2[_m];
        trackOffset = 0;
        srcSound = this.render(pattern.src, {});
        for (pieceIndex = _n = 0; 0 <= pieceCount ? _n < pieceCount : _n > pieceCount; pieceIndex = 0 <= pieceCount ? ++_n : --_n) {
          if ((pieceIndex < pattern.pattern.length) && (pattern.pattern[pieceIndex] !== '.')) {
            copyLen = srcSound.length;
            if ((trackOffset + copyLen) > totalLength) {
              copyLen = totalLength - trackOffset;
            }
            for (j = _o = 0; 0 <= copyLen ? _o < copyLen : _o > copyLen; j = 0 <= copyLen ? ++_o : --_o) {
              samples[trackOffset + j] += srcSound.samples[j];
            }
          }
          trackOffset += pieceLengths[pieceIndex];
        }
      }
      return {
        samples: samples,
        length: samples.length
      };
    };

    Renderer.prototype.calcCacheName = function(type, which, overrides) {
      var name;
      if (type !== 'tone') {
        return which;
      }
      name = which;
      if (overrides.note) {
        name += "/N" + overrides.note;
      }
      if (overrides.length) {
        name += "/L" + overrides.length;
      }
      return name;
    };

    Renderer.prototype.getObject = function(which) {
      var object;
      object = this.objects[which];
      if (!object) {
        this.error("no such object " + which);
        return null;
      }
      return object;
    };

    Renderer.prototype.render = function(which, overrides) {
      var cacheName, object, sound;
      object = this.getObject(which);
      if (!object) {
        return null;
      }
      cacheName = this.calcCacheName(object._type, which, overrides);
      if (this.soundCache[cacheName]) {
        return this.soundCache[cacheName];
      }
      sound = (function() {
        switch (object._type) {
          case 'tone':
            return this.renderTone(object, overrides);
          case 'loop':
            return this.renderLoop(object);
          case 'track':
            return this.renderTrack(object);
          case 'sample':
            return this.renderSample(object);
          default:
            this.error("unknown type " + object._type);
            return null;
        }
      }).call(this);
      this.log.verbose("Rendered " + cacheName + ".");
      this.soundCache[cacheName] = sound;
      return sound;
    };

    return Renderer;

  })();

  renderLoopScript = function(args) {
    var logObj, outputSound, parser, renderer, sampleRate, which;
    logObj = args.log;
    logObj.verbose("Parsing...");
    parser = new Parser(logObj);
    parser.parse(args.script);
    which = args.which;
    if (which == null) {
      which = parser.lastObject;
    }
    if (which) {
      sampleRate = 44100;
      logObj.verbose("Rendering...");
      renderer = new Renderer(logObj, sampleRate, args.readLocalFiles, parser.objects);
      outputSound = renderer.render(which, {});
      if (args.outputFilename) {
        return riffwave.writeWAV(args.outputFilename, sampleRate, outputSound.samples);
      }
      return riffwave.makeBlobUrl(sampleRate, outputSound.samples);
    }
    return null;
  };

  module.exports = {
    render: renderLoopScript
  };

}).call(this);

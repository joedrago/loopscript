// Generated by CoffeeScript 1.6.3
(function() {
  var IndentStack, Parser, Renderer, clone, countIndent, findFreq, fs, makeBlobUrl, renderLoopScript, writeWAV, _ref,
    __slice = [].slice;

  _ref = require("./riffwave"), writeWAV = _ref.writeWAV, makeBlobUrl = _ref.makeBlobUrl;

  findFreq = require('./freq').findFreq;

  fs = require('fs');

  clone = function(obj) {
    var flags, key, newInstance;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
      flags = '';
      if (obj.global != null) {
        flags += 'g';
      }
      if (obj.ignoreCase != null) {
        flags += 'i';
      }
      if (obj.multiline != null) {
        flags += 'm';
      }
      if (obj.sticky != null) {
        flags += 'y';
      }
      return new RegExp(obj.source, flags);
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      newInstance[key] = clone(obj[key]);
    }
    return newInstance;
  };

  IndentStack = (function() {
    function IndentStack() {
      this.stack = [0];
    }

    IndentStack.prototype.push = function(indent) {
      return this.stack.push(indent);
    };

    IndentStack.prototype.pop = function() {
      if (this.stack.length > 1) {
        this.stack.pop();
        return true;
      }
      return false;
    };

    IndentStack.prototype.top = function() {
      return this.stack[this.stack.length - 1];
    };

    return IndentStack;

  })();

  countIndent = function(text) {
    var i, indent, _i, _ref1;
    indent = 0;
    for (i = _i = 0, _ref1 = text.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
      if (text[i] === '\t') {
        indent += 8;
      } else {
        indent++;
      }
    }
    return indent;
  };

  Parser = (function() {
    function Parser(log) {
      this.log = log;
      this.commentRegex = /^([^#]*?)(\s*#.*)?$/;
      this.onlyWhitespaceRegex = /^\s*$/;
      this.indentRegex = /^(\s*)(\S.*)$/;
      this.leadingUnderscoreRegex = /^_/;
      this.hasCapitalLettersRegex = /[A-Z]/;
      this.isNoteRegex = /[A-La-l]/;
      this.namedStates = {
        "default": {
          wave: 'sine',
          bpm: 120,
          duration: 200,
          beats: 4,
          octave: 4,
          note: 'a',
          volume: 1.0,
          adsr: {
            a: 0,
            d: 0,
            s: 1,
            r: 1
          }
        }
      };
      this.objectKeys = {
        tone: {
          wave: 'string',
          freq: 'float',
          duration: 'float',
          adsr: 'adsr',
          octave: 'int',
          note: 'string',
          volume: 'float'
        },
        sample: {
          src: 'string',
          volume: 'float'
        },
        loop: {
          bpm: 'int',
          beats: 'int'
        },
        track: {}
      };
      this.indentStack = new IndentStack;
      this.stateStack = [];
      this.reset('default');
      this.objects = {};
      this.object = null;
      this.objectScopeReady = false;
    }

    Parser.prototype.isObjectType = function(type) {
      return this.objectKeys[type] != null;
    };

    Parser.prototype.error = function(text) {
      return this.log("PARSE ERROR, line " + this.lineNo + ": " + text);
    };

    Parser.prototype.reset = function(name) {
      if (name == null) {
        name = 'default';
      }
      if (!this.namedStates[name]) {
        this.error("invalid reset name: " + name);
        return false;
      }
      this.stateStack.push(clone(this.namedStates[name]));
      return true;
    };

    Parser.prototype.flatten = function() {
      var flattenedState, key, state, _i, _len, _ref1;
      flattenedState = {};
      _ref1 = this.stateStack;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        state = _ref1[_i];
        for (key in state) {
          flattenedState[key] = state[key];
        }
      }
      return flattenedState;
    };

    Parser.prototype.trace = function(prefix) {
      if (prefix == null) {
        prefix = '';
      }
      return this.log(("trace: " + prefix + " ") + JSON.stringify(this.flatten()));
    };

    Parser.prototype.createObject = function() {
      var data, i, _i, _ref1;
      data = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.finishObject();
      this.object = {};
      for (i = _i = 0, _ref1 = data.length; _i < _ref1; i = _i += 2) {
        this.object[data[i]] = data[i + 1];
      }
      this.objectScopeReady = true;
      if (this.object._type === 'loop') {
        this.object._patterns = [];
      }
      if (this.object._type === 'track') {
        this.object._patterns = [];
      }
      if (this.object._name) {
        return this.lastObject = this.object._name;
      }
    };

    Parser.prototype.finishObject = function() {
      var expectedType, key, state, v;
      if (this.object) {
        state = this.flatten();
        for (key in this.objectKeys[this.object._type]) {
          expectedType = this.objectKeys[this.object._type][key];
          if (state[key] != null) {
            v = state[key];
            this.object[key] = (function() {
              switch (expectedType) {
                case 'int':
                  return parseInt(v);
                case 'float':
                  return parseFloat(v);
                default:
                  return v;
              }
            })();
          }
        }
        this.objects[this.object._name] = this.object;
      }
      return this.object = null;
    };

    Parser.prototype.creatingObjectType = function(type) {
      if (!this.object) {
        return false;
      }
      if (!this.object._type === type) {
        return false;
      }
      return true;
    };

    Parser.prototype.pushScope = function() {
      if (!this.objectScopeReady) {
        this.error("unexpected indent");
        return false;
      }
      this.objectScopeReady = false;
      this.stateStack.push({
        _scope: true
      });
      return true;
    };

    Parser.prototype.popScope = function() {
      var top;
      this.finishObject();
      while (true) {
        if (this.stateStack.length === 0) {
          this.error("state stack is empty! something bad has happened");
        }
        top = this.stateStack[this.stateStack.length - 1];
        if (top._scope != null) {
          break;
        }
        this.stateStack.pop();
      }
      this.stateStack.pop();
      return true;
    };

    Parser.prototype.parsePattern = function(pattern) {
      var c, i, length, next, overrideLength, sound, sounds, symbol;
      overrideLength = this.hasCapitalLettersRegex.test(pattern);
      i = 0;
      sounds = [];
      while (i < pattern.length) {
        c = pattern[i];
        if (c !== '.') {
          symbol = c.toLowerCase();
          sound = {
            offset: i
          };
          if (this.isNoteRegex.test(c)) {
            sound.note = symbol;
          }
          if (overrideLength) {
            length = 1;
            while (true) {
              next = pattern[i + 1];
              if (next === symbol) {
                length++;
                i++;
                if (i === pattern.length) {
                  break;
                }
              } else {
                break;
              }
            }
            sound.length = length;
          }
          sounds.push(sound);
        }
        i++;
      }
      return {
        length: pattern.length,
        sounds: sounds
      };
    };

    Parser.prototype.processTokens = function(tokens) {
      var cmd, pattern;
      cmd = tokens[0].toLowerCase();
      if (cmd === 'reset') {
        if (!this.reset(tokens[1])) {
          return false;
        }
      } else if (cmd === 'section') {
        this.objectScopeReady = true;
      } else if (this.isObjectType(cmd)) {
        this.createObject('_type', cmd, '_name', tokens[1]);
      } else if (cmd === 'pattern') {
        if (!(this.creatingObjectType('loop') || this.creatingObjectType('track'))) {
          this.error("unexpected pattern command");
          return false;
        }
        pattern = this.parsePattern(tokens[2]);
        pattern.src = tokens[1];
        this.object._patterns.push(pattern);
      } else if (cmd === 'adsr') {
        this.stateStack[this.stateStack.length - 1][cmd] = {
          a: parseFloat(tokens[1]),
          d: parseFloat(tokens[2]),
          s: parseFloat(tokens[3]),
          r: parseFloat(tokens[4])
        };
      } else {
        if (this.leadingUnderscoreRegex.test(cmd)) {
          this.error("cannot set internal names (underscore prefix)");
          return false;
        }
        this.stateStack[this.stateStack.length - 1][cmd] = tokens[1];
      }
      return true;
    };

    Parser.prototype.parse = function(text) {
      var indent, indentText, line, lines, topIndent, _, _i, _len, _ref1;
      lines = text.split('\n');
      this.lineNo = 0;
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        this.lineNo++;
        line = line.replace(/(\r\n|\n|\r)/gm, "");
        line = this.commentRegex.exec(line)[1];
        if (this.onlyWhitespaceRegex.test(line)) {
          continue;
        }
        _ref1 = this.indentRegex.exec(line), _ = _ref1[0], indentText = _ref1[1], line = _ref1[2];
        indent = countIndent(indentText);
        topIndent = this.indentStack.top();
        if (indent === topIndent) {

        } else if (indent > topIndent) {
          this.indentStack.push(indent);
          if (!this.pushScope()) {
            return false;
          }
        } else {
          while (true) {
            if (!this.indentStack.pop()) {
              this.log("Unexpected indent " + indent + " on line " + lineNo + ": " + line);
              return false;
            }
            if (!this.popScope()) {
              return false;
            }
            if (this.indentStack.top() === indent) {
              break;
            }
          }
        }
        if (!this.processTokens(line.split(/\s+/))) {
          return false;
        }
      }
      while (this.indentStack.pop()) {
        this.popScope();
      }
      this.finishObject();
      return true;
    };

    return Parser;

  })();

  Renderer = (function() {
    function Renderer(log, sampleRate, readLocalFiles, objects) {
      this.log = log;
      this.sampleRate = sampleRate;
      this.readLocalFiles = readLocalFiles;
      this.objects = objects;
      this.sampleCache = {};
    }

    Renderer.prototype.error = function(text) {
      return this.log("RENDER ERROR: " + text);
    };

    Renderer.prototype.generateEnvelope = function(adsr, length) {
      var AtoD, DtoS, StoR, attackLen, decayLen, envelope, i, peakSustainDelta, releaseLen, sustain, sustainLen, _i, _j, _k, _l;
      envelope = Array(length);
      AtoD = Math.floor(adsr.a * length);
      DtoS = Math.floor(adsr.d * length);
      StoR = Math.floor(adsr.r * length);
      attackLen = AtoD;
      decayLen = DtoS - AtoD;
      sustainLen = StoR - DtoS;
      releaseLen = length - StoR;
      sustain = adsr.s;
      peakSustainDelta = 1.0 - sustain;
      for (i = _i = 0; 0 <= attackLen ? _i < attackLen : _i > attackLen; i = 0 <= attackLen ? ++_i : --_i) {
        envelope[i] = i / attackLen;
      }
      for (i = _j = 0; 0 <= decayLen ? _j < decayLen : _j > decayLen; i = 0 <= decayLen ? ++_j : --_j) {
        envelope[AtoD + i] = 1.0 - (peakSustainDelta * (i / decayLen));
      }
      for (i = _k = 0; 0 <= sustainLen ? _k < sustainLen : _k > sustainLen; i = 0 <= sustainLen ? ++_k : --_k) {
        envelope[DtoS + i] = sustain;
      }
      for (i = _l = 0; 0 <= releaseLen ? _l < releaseLen : _l > releaseLen; i = 0 <= releaseLen ? ++_l : --_l) {
        envelope[StoR + i] = sustain - (sustain * (i / releaseLen));
      }
      return envelope;
    };

    Renderer.prototype.renderTone = function(toneObj, overrides) {
      var A, B, amplitude, envelope, freq, i, length, offset, period, samples, sine, _i;
      offset = 0;
      amplitude = 16000;
      if (overrides.length > 0) {
        length = overrides.length;
      } else {
        length = Math.floor(toneObj.duration * this.sampleRate / 1000);
      }
      samples = Array(length);
      A = 200;
      B = 0.5;
      if (overrides.note != null) {
        freq = findFreq(toneObj.octave, overrides.note);
      } else if (toneObj.freq != null) {
        freq = toneObj.freq;
      } else {
        freq = findFreq(toneObj.octave, toneObj.note);
      }
      envelope = this.generateEnvelope(toneObj.adsr, length);
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        period = this.sampleRate / freq;
        sine = Math.sin(offset + i / period * 2 * Math.PI);
        samples[i] = sine * amplitude * envelope[i] * toneObj.volume;
      }
      return samples;
    };

    Renderer.prototype.renderSample = function(sampleObj) {
      var data, i, jDataView, samples, subchunk2Size, view, _i, _ref1;
      view = null;
      if (this.readLocalFiles) {
        if (typeof jDataView === "undefined" || jDataView === null) {
          jDataView = require('./jDataView');
        }
        data = fs.readFileSync(sampleObj.src);
        view = new jDataView(data, 0, data.length, true);
      } else {
        $.ajax({
          url: sampleObj.src,
          mimeType: 'text/plain; charset=x-user-defined',
          success: function(data) {
            return view = new jDataView(data, 0, data.length, true);
          },
          async: false
        });
      }
      if (!view) {
        return [];
      }
      view.seek(40);
      subchunk2Size = view.getInt32();
      samples = [];
      while (view.tell() + 1 < view.byteLength) {
        samples.push(view.getInt16());
      }
      for (i = _i = 0, _ref1 = samples.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        samples[i] *= sampleObj.volume;
      }
      return samples;
    };

    Renderer.prototype.renderPatterns = function(patterns, totalLength, calcOffsetLength) {
      var copyLen, i, j, offset, offsetLength, overrides, pattern, samples, sectionCount, sound, srcSamples, _i, _j, _k, _l, _len, _len1, _ref1;
      samples = Array(totalLength);
      for (i = _i = 0; 0 <= totalLength ? _i < totalLength : _i > totalLength; i = 0 <= totalLength ? ++_i : --_i) {
        samples[i] = 0;
      }
      for (_j = 0, _len = patterns.length; _j < _len; _j++) {
        pattern = patterns[_j];
        _ref1 = pattern.sounds;
        for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
          sound = _ref1[_k];
          overrides = {};
          sectionCount = pattern.length / 16;
          offsetLength = Math.floor(totalLength / 16 / sectionCount);
          if (sound.length > 0) {
            overrides.length = sound.length * offsetLength;
          }
          if (sound.note != null) {
            overrides.note = sound.note;
          }
          srcSamples = this.render(pattern.src, overrides);
          if (!calcOffsetLength) {
            offsetLength = srcSamples.length;
          }
          offset = sound.offset * offsetLength;
          copyLen = srcSamples.length;
          if ((offset + copyLen) > totalLength) {
            copyLen = totalLength - offset;
          }
          for (j = _l = 0; 0 <= copyLen ? _l < copyLen : _l > copyLen; j = 0 <= copyLen ? ++_l : --_l) {
            samples[offset + j] += srcSamples[j];
          }
        }
      }
      return samples;
    };

    Renderer.prototype.renderLoop = function(loopObj) {
      var beatCount, loopLength, pattern, samplesPerBeat, _i, _len, _ref1;
      beatCount = 0;
      _ref1 = loopObj._patterns;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        pattern = _ref1[_i];
        if (beatCount < pattern.length) {
          beatCount = pattern.length;
        }
      }
      samplesPerBeat = this.sampleRate / (loopObj.bpm / 60) / loopObj.beats;
      loopLength = samplesPerBeat * beatCount;
      return this.renderPatterns(loopObj._patterns, loopLength, true);
    };

    Renderer.prototype.renderTrack = function(trackObj) {
      var pattern, patternLength, srcSamples, trackLength, _i, _len, _ref1;
      trackLength = 0;
      _ref1 = trackObj._patterns;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        pattern = _ref1[_i];
        srcSamples = this.render(pattern.src);
        patternLength = srcSamples.length * pattern.length;
        if (trackLength < patternLength) {
          trackLength = patternLength;
        }
      }
      return this.renderPatterns(trackObj._patterns, trackLength, false);
    };

    Renderer.prototype.calcCacheName = function(type, which, overrides) {
      var name;
      if (type !== 'tone') {
        return which;
      }
      name = which;
      if (overrides.note) {
        name += "/N" + overrides.note;
      }
      if (overrides.length) {
        name += "/L" + overrides.length;
      }
      return name;
    };

    Renderer.prototype.render = function(which, overrides) {
      var cacheName, object, samples;
      object = this.objects[which];
      if (!object) {
        this.error("no such object " + which);
        return null;
      }
      cacheName = this.calcCacheName(object._type, which, overrides);
      if (this.sampleCache[cacheName]) {
        return this.sampleCache[cacheName];
      }
      samples = (function() {
        switch (object._type) {
          case 'tone':
            return this.renderTone(object, overrides);
          case 'loop':
            return this.renderLoop(object);
          case 'track':
            return this.renderTrack(object);
          case 'sample':
            return this.renderSample(object);
          default:
            this.error("unknown type " + object._type);
            return null;
        }
      }).call(this);
      this.log("Rendered " + cacheName + ".");
      this.sampleCache[cacheName] = samples;
      return samples;
    };

    return Renderer;

  })();

  renderLoopScript = function(args) {
    var logCB, outputSamples, parser, renderer, sampleRate, which;
    logCB = args.log;
    logCB("Parsing...");
    parser = new Parser(logCB);
    parser.parse(args.script);
    which = args.which;
    if (which == null) {
      which = parser.lastObject;
    }
    if (which) {
      sampleRate = 44100;
      logCB("Rendering...");
      renderer = new Renderer(logCB, sampleRate, args.readLocalFiles, parser.objects);
      outputSamples = renderer.render(parser.lastObject, {});
      if (args.outputFilename) {
        return writeWAV(args.outputFilename, sampleRate, outputSamples);
      }
      return makeBlobUrl(sampleRate, outputSamples);
    }
    return null;
  };

  module.exports = {
    render: renderLoopScript
  };

}).call(this);

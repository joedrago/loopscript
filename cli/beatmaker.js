// Generated by CoffeeScript 1.8.0
(function() {
  var BeatMaker, main;

  (function() {
    var nowOffset;
    if (typeof window.performance === 'undefined') {
      window.performance = {};
    }
    if (!window.performance.now) {
      nowOffset = +new Date();
      if (performance.timing && performance.timing) {
        nowOffset = performance.timing.navigationStart;
      }
      return window.performance.now = function() {
        var now;
        now = +new Date();
        return now - nowOffset;
      };
    }
  })();

  BeatMaker = (function() {
    function BeatMaker() {
      this.reset();
    }

    BeatMaker.prototype.setInputText = function(text) {
      return $("#beatinput").val(text);
    };

    BeatMaker.prototype.setOutputText = function(text) {
      return $("#beatoutput").html(text);
    };

    BeatMaker.prototype.error = function(text) {
      return this.setInputText(" ERROR: " + text);
    };

    BeatMaker.prototype.reset = function(note) {
      this.keyDownCount = 0;
      this.keyDownTime = {};
      this.recording = false;
      this.notes = [];
      if (note == null) {
        note = "";
      }
      return this.setInputText("" + note + " Click here and hit use A-Z keys to make a new beat (please loop the full pattern exactly twice)");
    };

    BeatMaker.prototype.updateRecording = function() {
      var now;
      if (!this.recording) {
        return;
      }
      now = window.performance.now();
      if (now > (this.lastKeyEvent + 2000)) {
        return $("#beatinput").val(" Recording (" + (Math.floor(4000 - (now - this.lastKeyEvent))) + " ms left...)...");
      } else {
        return $("#beatinput").val(" Recording...");
      }
    };

    BeatMaker.prototype.startRecording = function() {
      this.recording = true;
      return this.updateRecording();
    };

    BeatMaker.prototype.stopRecording = function() {
      var recordedNotes;
      recordedNotes = this.notes;
      this.reset(" Recording finished.");
      return this.generate(recordedNotes);
    };

    BeatMaker.prototype.keyDown = function(key, ts) {
      if (this.keyDownTime.hasOwnProperty(key)) {
        return;
      }
      this.lastKeyEvent = window.performance.now();
      if (!this.recording) {
        this.startRecording();
      }
      this.keyDownTime[key] = ts;
      return this.keyDownCount++;
    };

    BeatMaker.prototype.keyUp = function(key, ts) {
      if (!this.recording) {
        return;
      }
      this.lastKeyEvent = window.performance.now();
      this.notes.push({
        key: key,
        start: this.keyDownTime[key],
        end: ts
      });
      delete this.keyDownTime[key];
      return this.keyDownCount--;
    };

    BeatMaker.prototype.tick = function() {
      var now;
      if (!this.recording) {
        return;
      }
      this.updateRecording();
      if (this.keyDownCount > 0) {
        return;
      }
      now = window.performance.now();
      if (now > (this.lastKeyEvent + 4000)) {
        return this.stopRecording();
      }
    };

    BeatMaker.prototype.generate = function(notes) {
      var baseBPM, beat, beatStart, beatTime, i, key, keyNotes, loopCount, note, noteCount, noteIndex, pieceCount, pieceIndex, pieceSeen, pieceTime, pieces, _i, _j, _k, _l, _len, _len1, _m, _n;
      notes.sort(function(a, b) {
        return a.start - b.start;
      });
      if ((notes.length % 2) !== 0) {
        this.error("Odd count of notes! Please loop your beat exactly twice.");
        return;
      }
      beat = "";
      beatStart = notes[0].start;
      noteCount = notes.length >> 1;
      beatTime = notes[noteCount].start - beatStart;
      beat += "# " + noteCount + " notes, total time " + beatTime + " seconds\n";
      baseBPM = Math.floor(120000 / beatTime);
      while (baseBPM > 60) {
        baseBPM >>= 1;
      }
      beat += "# BPM guesses: " + baseBPM + ", " + (baseBPM * 2) + ", " + (baseBPM * 4) + "\n";
      beat += "\n# Here is your beat at various levels of granularity:\n";
      keyNotes = {};
      for (noteIndex = _i = 0; 0 <= noteCount ? _i < noteCount : _i > noteCount; noteIndex = 0 <= noteCount ? ++_i : --_i) {
        note = notes[noteIndex];
        if (!keyNotes.hasOwnProperty(note.key)) {
          keyNotes[note.key] = [];
        }
        keyNotes[note.key].push({
          start: note.start - beatStart,
          length: note.end - note.start
        });
      }
      pieceCount = 8;
      pieceTime = 0;
      for (loopCount = _j = 0; _j < 3; loopCount = ++_j) {
        pieceCount <<= 1;
        console.log("trying to fit in " + pieceCount + " pieces");
        beat += "\nloop pattern" + pieceCount + "\n";
        pieceTime = beatTime / pieceCount;
        for (key in keyNotes) {
          notes = keyNotes[key];
          console.log("* fitting key " + key);
          pieceSeen = [];
          for (i = _k = 0; 0 <= pieceCount ? _k < pieceCount : _k > pieceCount; i = 0 <= pieceCount ? ++_k : --_k) {
            pieceSeen[i] = false;
          }
          for (_l = 0, _len = notes.length; _l < _len; _l++) {
            note = notes[_l];
            pieceIndex = Math.floor((note.start + (pieceTime / 2)) / pieceTime);
            console.log("piece index for " + note.start + " is " + pieceIndex);
            if (pieceSeen[pieceIndex]) {
              console.log("already saw index " + pieceIndex + " for key " + key + ", doubling pieceCount");
              loopCount = 0;
              continue;
            }
          }
        }
        for (key in keyNotes) {
          notes = keyNotes[key];
          console.log("* rendering key " + key);
          pieces = [];
          for (i = _m = 0; 0 <= pieceCount ? _m < pieceCount : _m > pieceCount; i = 0 <= pieceCount ? ++_m : --_m) {
            pieces[i] = ".";
          }
          for (_n = 0, _len1 = notes.length; _n < _len1; _n++) {
            note = notes[_n];
            pieceIndex = Math.floor((note.start + (pieceTime / 2)) / pieceTime);
            console.log("piece index for " + note.start + " is " + pieceIndex);
            pieces[pieceIndex] = "x";
          }
          beat += ("  pattern " + key + " ") + pieces.join("") + "\n";
        }
      }
      console.log(keyNotes);
      return this.setOutputText(beat);
    };

    return BeatMaker;

  })();

  main = function() {
    var beatmaker;
    beatmaker = new BeatMaker;
    $('#beatinput').keydown(function(event) {
      var key, keyCode, now;
      keyCode = parseInt(event.keyCode);
      if ((keyCode < 65) || (keyCode > 90)) {
        return;
      }
      key = String.fromCharCode(event.keyCode);
      now = window.performance.now();
      return beatmaker.keyDown(key, now);
    });
    $('#beatinput').keyup(function(event) {
      var key, keyCode, now;
      keyCode = parseInt(event.keyCode);
      if ((keyCode < 65) || (keyCode > 90)) {
        return;
      }
      key = String.fromCharCode(event.keyCode);
      now = window.performance.now();
      return beatmaker.keyUp(key, now);
    });
    return setInterval(function() {
      return beatmaker.tick();
    }, 250);
  };

  main();

  module.exports = {
    lel: "playz"
  };

}).call(this);
